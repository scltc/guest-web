// Original ideas from:
//   Using WebSockets in Angular with RxJs WebSocketSubject
//   https://medium.com/@alexdasoul/%D0%B8%D1%81%D0%BF%D0%BE%D0%BB%D1%8C%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-websockets-%D0%B2-angular-c-rxjs-websocketsubject-5018ecc20ee5
//   https://github.com/Angular-RU/angular-websocket-starter

import { Injectable, OnDestroy, Inject } from '@angular/core';

import { Observable, Observer, Subject, SubscriptionLike, interval } from 'rxjs';
import { distinctUntilChanged, filter, map, share, takeWhile } from 'rxjs/operators';
import { WebSocketSubject, WebSocketSubjectConfig, webSocket } from 'rxjs/websocket';

import { IControllerService, IControllerMessage, IControllerConfiguration } from './controller.interfaces';


@Injectable({
    providedIn: 'root'
})
export class ControllerService implements IControllerService, OnDestroy {

    private config: WebSocketSubjectConfig<IControllerMessage<any>>;
    private pinger: Observable<number> = interval(1000 * 5);

    private socketSubscription: SubscriptionLike;
    private statusSubscription: SubscriptionLike;
    private pingerSubscription: SubscriptionLike;

    private reconnection$: Observable<number>;
    private websocket$: WebSocketSubject<IControllerMessage<any>>;
    private connection$: Observer<boolean>;
    private wsMessages$: Subject<IControllerMessage<any>>;

    private reconnectInterval: number;
    private reconnectAttempts: number;
    private isConnected: boolean;

    private logMessage(message: any) {
        console.log(JSON.stringify(message));
    }

    private logSerious(message: any, error?: any) {
        if (error) {
            console.error(JSON.stringify(message), error);
        }
        else {
            console.error(JSON.stringify(message));
        }
    }

    public status: Observable<boolean>;

    constructor(@Inject('configuration') private configuration: IControllerConfiguration) {

        this.logMessage('WebSocket.constructor()');
        this.logMessage(configuration);

        this.wsMessages$ = new Subject<IControllerMessage<any>>();

        this.reconnectInterval = configuration.reconnectInterval || 5000; // pause between connections
        this.reconnectAttempts = configuration.reconnectAttempts || 10; // number of connection attempts

        // Create the WebSocketSubject configuratiom.
        this.config = {
            url: configuration.url,
            closeObserver: {
                next: (event: CloseEvent) => {
                    this.logMessage('WebSocket.closeObserver() : ' + JSON.stringify(event));
                    this.websocket$ = null;
                    this.connection$.next(false);
                }
            },
            openObserver: {
                next: (event: Event) => {
                    this.logMessage('WebSocket.openObserver() : ' + JSON.stringify(event));
                    this.logMessage('WebSocket connected!');
                    this.connection$.next(true);
                }
            }
        };

        // Create the connection status observable.
        this.status = new Observable<boolean>((observer) => {
            this.connection$ = observer;
        }).pipe(share(), distinctUntilChanged());

        // run reconnect if not connection
        this.statusSubscription = this.status.subscribe((isConnected) => {
            if (!this.reconnection$ && typeof (isConnected) === 'boolean' && !isConnected) {
                this.reconnect();
            }

            if (typeof(isConnected) === 'boolean' && isConnected) {
                this.logMessage('requesting settings.')
                this.send('getSettings');
            }
        });

        this.socketSubscription = this.wsMessages$.subscribe(null, (error: ErrorEvent) =>
            this.logSerious('WebSocket error!', error)
        );

        this.connect();

        this.pingerSubscription = this.pinger.subscribe(x => {
            if (this.isConnected) {
                this.logMessage(`send: ping ${x}`);

                this.send('ping', { value: x });
            }
        });
    }

    ngOnDestroy() {
        this.socketSubscription.unsubscribe();
        this.statusSubscription.unsubscribe();
        this.pingerSubscription.unsubscribe();
    }

    /*
    Connect WebSocket.
    */
    private connect(): void {
        this.websocket$ = webSocket(this.config);

        this.websocket$.subscribe(
            (message) => {
                this.logMessage('receive: ' + JSON.stringify(message));
                this.wsMessages$.next(message);
            },
            (error: Event) => {
                this.logSerious('WebSocket error!', error);
                /* if (!this.websocket$) */ {
                    // run reconnect if errors
                    this.reconnect();
                }
            },
            () => {
                this.logMessage('WebSocket complete.');
            }
        );
    }

    /*
    Reconnect if not connecting or errors
    */
    private reconnect(): void {
        this.reconnection$ = interval(this.reconnectInterval)
            .pipe(takeWhile((v, index) => (this.reconnectAttempts < 0 || index < this.reconnectAttempts) && !this.websocket$)
        );

        this.reconnection$.subscribe(
            () => {
                this.logMessage('Reconnect attempt. reconectAtempts: ' + this.reconnectAttempts)
                this.connect();
            },
            null,
            () => {
                this.logMessage('reconnect failed.');
                // Subject complete if reconnect attempts ending
                this.reconnection$ = null;

                if (!this.websocket$) {
                    this.wsMessages$.complete();
                    this.connection$.complete();
                }
            }
        );
    }

    /*
    On message event.
    */
    public on<T>(method: string): Observable<T> {
        if (method) {
            // let method : String = "ping";
            return this.wsMessages$.pipe(
                filter((message: IControllerMessage<T>) => message.method === method),
                map((message: IControllerMessage<T>) => message.params)
            );
        }
    }

    /*
    Send message to server.
    */
    public send(method: string, params?: any): void {
        if (method && this.isConnected) {
            this.websocket$.next({ jsonrpc: "2.0", method: method, params: params, id: 0 });
        } else {
            this.logSerious('Send error!');
        }
    }
}
